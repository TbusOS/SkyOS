# 实验01: ARM32启动与基础IO

## 🎯 实验目标

通过本实验，学生将：
1. 理解ARM32处理器的启动过程
2. 掌握ARM汇编语言基础
3. 学会配置ARM异常向量表
4. 实现基本的UART串口输出
5. 理解ARM处理器模式和寄存器
6. **学会查找和理解硬件规格文档**

## 📚 理论背景

### ARM32架构基础

ARM32是一种RISC架构，具有以下特点：
- **32位指令集**: 每条指令固定32位长度
- **多种处理器模式**: User、System、Supervisor、IRQ、FIQ、Abort、Undefined
- **丰富的寄存器**: R0-R15，其中R13=SP，R14=LR，R15=PC
- **条件执行**: 大部分指令可以条件执行
- **移位操作**: 可在一条指令中完成数据处理和移位

### ARM处理器模式

| 模式 | 编码 | 用途 | 特权级别 |
|------|------|------|----------|
| User | 10000 | 用户程序 | 非特权 |
| FIQ | 10001 | 快速中断 | 特权 |
| IRQ | 10010 | 普通中断 | 特权 |
| Supervisor | 10011 | 系统调用/复位 | 特权 |
| Abort | 10111 | 内存访问异常 | 特权 |
| Undefined | 11011 | 未定义指令 | 特权 |
| System | 11111 | 特权用户模式 | 特权 |

### 异常向量表

ARM处理器的异常向量表固定位置存放各种异常的处理入口：

```
地址       异常类型
0x00       复位 (Reset)
0x04       未定义指令 (Undefined Instruction)  
0x08       软件中断 (Software Interrupt)
0x0C       预取指令异常 (Prefetch Abort)
0x10       数据访问异常 (Data Abort)
0x14       保留
0x18       IRQ中断
0x1C       FIQ中断
```

## 🔍 硬件规格背景 ⭐ 

### 为什么内存从0x40000000开始？

**答案来源**: QEMU virt machine硬件规格

1. **查看QEMU源码** (`hw/arm/virt.c`):
```c
static const MemMapEntry base_memmap[] = {
    [VIRT_MEM] = { 0x40000000, LEGACY_RAMLIMIT_BYTES },
    // 主内存从0x40000000开始，这是QEMU开发者的设计决定
};
```

2. **使用QEMU命令查询**:
```bash
qemu-system-arm -machine virt -cpu cortex-a15 -S -monitor stdio
(qemu) info mtree  # 查看内存布局
```

3. **设备树验证**:
```bash
qemu-system-arm -machine virt -machine dumpdtb=virt.dtb
dtc -I dtb -O dts virt.dtb | grep memory
# 输出: memory@40000000 { reg = <0x00 0x40000000 0x00 0x10000000>; }
```

### UART基地址0x09000000从哪里来？

**答案来源**: ARM PL011 UART控制器在QEMU virt machine中的映射

1. **QEMU virt machine规格** (`hw/arm/virt.c`):
```c
static const MemMapEntry base_memmap[] = {
    [VIRT_UART] = { 0x09000000, 0x00001000 },
    // UART0映射到0x09000000，大小4KB
};
```

2. **设备树确认**:
```bash
# 生成设备树并查看UART配置
qemu-system-arm -machine virt -machine dumpdtb=virt.dtb
dtc -I dtb -O dts virt.dtb | grep -A 5 "uart@"
# 输出: pl011@9000000 { reg = <0x00 0x9000000 0x00 0x1000>; }
```

### UART寄存器偏移地址的来源？

**答案来源**: ARM PL011 UART技术参考手册

| 寄存器 | 偏移 | 来源文档 | 说明 |
|--------|------|----------|------|
| UARTDR | 0x000 | PL011 TRM Table 3-2 | 数据寄存器 |
| UARTFR | 0x018 | PL011 TRM Table 3-2 | 标志寄存器 |
| UART_FR_TXFF | bit 5 | PL011 TRM Section 3.3.6 | 发送FIFO满标志 |

**官方文档**: ARM PrimeCell UART (PL011) Technical Reference Manual (ARM DDI 0183)

### 协处理器寄存器访问

```c
// 获取处理器ID的指令来源
uint32_t get_processor_id(void) {
    uint32_t id;
    asm volatile("mrc p15, 0, %0, c0, c0, 0" : "=r"(id));
    return id;
}
```

**指令编码来源**: ARMv7-A Architecture Reference Manual, Section B4.1.106

- `p15`: 系统控制协处理器
- `c0, c0, 0`: Main ID Register (MIDR)
- 功能: 读取处理器标识信息

## 🛠️ 实验环境

### 软件要求
- Ubuntu 20.04 或更新版本
- ARM交叉编译工具链: `gcc-arm-none-eabi`
- QEMU ARM系统模拟器: `qemu-system-arm`
- 文本编辑器 (VS Code推荐)
- **设备树编译器**: `device-tree-compiler` (用于分析硬件布局)

### 环境搭建
```bash
# 安装必要工具
sudo apt-get update
sudo apt-get install gcc-arm-none-eabi qemu-system-arm make device-tree-compiler

# 验证安装
arm-none-eabi-gcc --version
qemu-system-arm --version
dtc --version

# 克隆代码仓库
git clone https://github.com/TbusOS/SkyOS.git
cd SkyOS
```

## 📋 实验步骤

### 步骤1: 理解项目结构

查看项目目录结构：
```bash
tree SkyOS/
```

重点理解以下文件：
- `boot/start.S`: ARM启动汇编代码
- `boot/boot.lds`: 链接脚本
- `kernel/main.c`: C语言主函数
- `Makefile`: 构建脚本
- **`docs/labs/ARM32硬件规格说明.md`**: 硬件规格详解 ⭐

### 步骤2: 分析硬件规格 ⭐ 

在分析代码之前，先理解硬件环境：

```bash
# 查看QEMU virt machine的设备树
qemu-system-arm -machine virt -cpu cortex-a15 -machine dumpdtb=virt.dtb
dtc -I dtb -O dts virt.dtb > virt.dts

# 分析关键部分
grep -A 5 "memory@" virt.dts     # 内存布局
grep -A 5 "uart@" virt.dts       # UART配置
grep -A 5 "timer@" virt.dts      # 定时器配置
```

**练习**: 找出以下信息并验证代码中的定义
- 主内存起始地址和大小
- UART基地址和中断号
- 定时器地址和中断号

### 步骤3: 分析启动代码

打开 `boot/start.S`，逐行理解：

```assembly
.section .vectors, "ax"
.global _vectors
_vectors:
    ldr pc, =reset_handler      @ 0x00: Reset
    ldr pc, =undef_handler      @ 0x04: Undefined Instruction
    ...
```

**深入思考题**:
1. **为什么使用 `ldr pc, =address` 而不是直接 `b address`？**
   - `b address` 是相对跳转，范围±32MB
   - `ldr pc, =address` 是绝对跳转，可跳转到任意地址
   - 异常处理程序位置不确定，需要绝对跳转

2. **异常向量表为什么在这个位置？**
   - ARM架构规定的固定地址（可通过VBAR重定位）
   - QEMU virt machine将入口点设置为0x40000000
   - 链接脚本将.vectors段放在最开始

### 步骤4: 理解内存布局

分析 `boot/boot.lds` 链接脚本：

```ld
MEMORY
{
    RAM (rwx) : ORIGIN = 0x40000000, LENGTH = 256M
}

SECTIONS
{
    . = 0x40000000;
    
    .vectors : { KEEP(*(.vectors)) } > RAM
    .text : { *(.text*) } > RAM
    .data : { *(.data*) } > RAM
    .bss : { 
        __bss_start = .;
        *(.bss*) 
        __bss_end = .;
    } > RAM
}
```

**验证内存布局**:
```bash
# 编译后查看符号表
make all
arm-none-eabi-objdump -t build/skyos.elf | grep -E "(bss|text|vectors)"
```

### 步骤5: 分析UART驱动

理解 `kernel/main.c` 中的UART操作：

```c
// 这些地址不是"猜"出来的，而是有明确来源的！
#define UART0_BASE      0x09000000    // 来源: QEMU virt machine规格
#define UART_DR         (UART0_BASE + 0x00)  // 来源: PL011 TRM Table 3-2
#define UART_FR         (UART0_BASE + 0x18)  // 来源: PL011 TRM Table 3-2
#define UART_FR_TXFF    (1 << 5)      // 来源: PL011 TRM Section 3.3.6
```

**验证UART配置**:
```bash
# 查看设备树中的UART配置
dtc -I dtb -O dts virt.dtb | grep -A 10 "pl011@"
```

### 步骤6: 编译和运行

```bash
# 检查工具链
make check-toolchain

# 编译内核
make all

# 在QEMU中运行
make run
```

预期输出：
```
======================================
    SkyOS - ARM32 教学操作系统
======================================
版本: 0.1.0 (教学演示版)
架构: ARM Cortex-A15
处理器ID: 0x412FC0F1
当前模式: Supervisor (CPSR: 0x600001D3)
...
```

### 步骤7: 调试分析

在另一个终端窗口：
```bash
# 启动调试模式
make debug
```

在调试终端：
```bash
# 连接GDB
arm-none-eabi-gdb -ex 'target remote localhost:1234' build/skyos.elf

# 关键调试命令
(gdb) info registers               # 查看寄存器状态
(gdb) x/8i 0x40000000             # 查看异常向量表
(gdb) x/4x $sp                    # 查看栈内容
(gdb) disassemble _start          # 反汇编启动代码
(gdb) break main                  # 在main函数设断点
(gdb) continue                    # 继续执行
```

## 🔬 实验任务

### 任务1: 硬件规格探索 (必做) ⭐

1. **设备树分析**
   - 生成QEMU virt machine的设备树文件
   - 找出所有外设的基地址和中断号
   - 制作一个硬件资源映射表

2. **内存布局验证**
   - 使用`objdump`查看编译后的符号表
   - 验证链接脚本中的内存分配
   - 画出详细的内存布局图

3. **寄存器手册查阅**
   - 下载ARM PL011 UART技术参考手册
   - 找出所有寄存器的功能说明
   - 理解UART初始化的完整流程

### 任务2: 启动过程分析 (必做)

1. **启动流程追踪**
   - 使用GDB单步调试整个启动过程
   - 记录每个关键步骤的寄存器状态
   - 分析异常向量表的设置过程

2. **处理器状态分析**
   - 分析CPSR寄存器的各个位域含义
   - 理解处理器模式切换的机制
   - 验证堆栈指针的设置

### 任务3: 功能扩展 (必做)

1. **增强硬件信息显示**
   - 添加更多ARM系统寄存器的读取
   - 显示缓存配置信息
   - 显示内存布局信息

2. **改进UART驱动**
   - 实现UART接收功能
   - 添加波特率配置
   - 实现简单的输入回显

### 任务4: 深入探索 (选做)

1. **硬件移植实验**
   - 研究树莓派的硬件规格
   - 比较QEMU和真实硬件的差异
   - 尝试修改代码以支持其他平台

2. **性能分析**
   - 使用ARM性能计数器
   - 测量启动时间
   - 分析指令执行效率

## 📊 实验报告要求

### 报告结构

1. **硬件规格分析** (25%) ⭐
   - 详细的设备树分析结果
   - 硬件资源映射表
   - 寄存器手册查阅总结

2. **理论分析** (25%)
   - ARM32架构特点总结
   - 启动过程详细分析
   - 异常向量表机制说明

3. **实验过程** (30%)
   - 详细的实验步骤
   - 遇到的问题和解决方案
   - 关键代码分析

4. **结果分析** (15%)
   - 运行结果截图
   - 寄存器状态分析
   - 性能观察

5. **思考总结** (5%)
   - 对ARM架构的理解
   - 硬件规格文档的重要性
   - 改进建议

### 提交要求

- **源代码**: 包含所有修改的源文件
- **硬件分析**: 设备树文件和分析结果
- **实验报告**: PDF格式，不超过20页
- **演示视频**: 包含调试过程的演示

## 🤔 关键问题解答

### Q1: 这些神奇数字从哪里来？

**答案**: 没有神奇数字，一切都有来源！

- **内存地址**: QEMU源码 + 设备树 + 硬件规格书
- **寄存器偏移**: ARM官方技术参考手册  
- **位域定义**: 外设控制器数据手册
- **指令编码**: ARM架构参考手册

### Q2: 如何快速查找硬件信息？

**步骤**:
1. 查看设备树：`dtc -I dtb -O dts virt.dtb`
2. 使用QEMU monitor：`info mtree`, `info qtree`
3. 查阅官方文档：ARM Developer网站
4. 分析源码：QEMU、Linux内核

### Q3: 真实硬件和虚拟机有什么区别？

**主要差异**:
- **地址映射**: 每个平台都有自己的内存布局
- **外设配置**: 不同的UART、GPIO、中断控制器
- **时钟系统**: 晶振频率、分频器配置
- **电源管理**: 虚拟机没有真实的电源状态

## 🔗 参考资料

### 必读文档
1. **[ARM32硬件规格说明](ARM32硬件规格说明.md)** - 本项目专门文档
2. **QEMU ARM System Emulation**: https://qemu.readthedocs.io/en/latest/system/arm/virt.html
3. **ARM PL011 UART TRM**: ARM DDI 0183
4. **ARMv7-A Architecture Reference Manual**: ARM DDI 0406

### 实用工具
1. **设备树编译器**: `dtc` - 分析硬件布局
2. **QEMU monitor**: 运行时硬件查询
3. **GDB**: 寄存器和内存分析
4. **objdump**: 符号表和反汇编

## 📞 支持与帮助

- **技术问题**: 先查看硬件规格文档，再提问
- **实验指导**: 参考docs/labs/目录
- **硬件疑问**: 阅读ARM32硬件规格说明.md
- **讨论区**: 课程论坛实验01板块

---

**重要提醒**: 
- **所有数字都有来源，养成查阅文档的习惯！**
- **理解硬件是系统编程的基础**
- **多动手验证，不要死记硬背** 