# 实验02：ARM异常处理与中断

## 📋 实验概述

本实验将在阶段1的基础上，实现完整的ARM异常处理机制和中断控制系统，包括异常向量表、定时器中断、系统调用等核心功能。

## 🎯 实验目标

1. 实现完整的ARM异常向量表和处理程序
2. 配置和使用ARM Generic Timer产生定时器中断
3. 实现系统调用机制
4. 理解和配置GIC中断控制器
5. 验证异常处理的正确性和稳定性

## 🛠️ 实验环境

- 基于阶段1的SkyOS内核
- QEMU virt machine (ARM Cortex-A15)
- ARM GIC v2中断控制器
- ARM Generic Timer

## 📂 实验内容

### 实验2.1：完善异常向量表

#### 目标
实现完整的异常处理框架，能够处理各种ARM异常。

#### 步骤

**1. 增强异常向量表 (boot/start.S)**

在原有基础上增加完整的异常处理程序：

```assembly
/*
 * 完整的异常处理程序框架
 * 每个异常都有独立的处理程序
 */

undef_handler:
    @ 保存上下文
    stmfd sp!, {r0-r12, lr}
    
    @ 调用C语言异常处理函数
    bl handle_undefined_instruction
    
    @ 恢复上下文并返回
    ldmfd sp!, {r0-r12, pc}^

swi_handler:
    @ 保存上下文 (注意：SVC模式下lr指向返回地址)
    stmfd sp!, {r0-r12, lr}
    
    @ 获取SVC指令中的立即数
    ldr r0, [lr, #-4]
    bic r0, r0, #0xFF000000
    
    @ 从栈中获取寄存器参数
    mov r1, sp
    
    @ 调用系统调用处理函数
    bl handle_swi
    
    @ 恢复上下文并返回
    ldmfd sp!, {r0-r12, pc}^

prefetch_handler:
    stmfd sp!, {r0-r12, lr}
    bl handle_prefetch_abort
    ldmfd sp!, {r0-r12, pc}^

data_handler:
    stmfd sp!, {r0-r12, lr}
    bl handle_data_abort
    ldmfd sp!, {r0-r12, pc}^

irq_handler:
    @ 保存上下文到IRQ模式栈
    sub lr, lr, #4          @ 调整返回地址
    stmfd sp!, {r0-r12, lr}
    
    @ 调用C语言IRQ处理函数
    bl handle_irq
    
    @ 恢复上下文并返回
    ldmfd sp!, {r0-r12, pc}^

fiq_handler:
    @ FIQ有独立的寄存器组，处理更快
    stmfd sp!, {r0-r7, lr}
    bl handle_fiq
    ldmfd sp!, {r0-r7, pc}^
```

**2. 创建异常处理C函数 (kernel/exception.c)**

```c
#include <stdint.h>
#include "uart.h"

/* 异常信息结构 */
struct exception_frame {
    uint32_t r0, r1, r2, r3, r4, r5, r6, r7;
    uint32_t r8, r9, r10, r11, r12;
    uint32_t lr;
};

/* 未定义指令异常处理 */
void handle_undefined_instruction(struct exception_frame *frame) {
    uart_puts("*** UNDEFINED INSTRUCTION EXCEPTION ***\r\n");
    uart_puts("Registers:\r\n");
    uart_puts("  R0="); uart_put_hex(frame->r0); uart_puts("\r\n");
    uart_puts("  R1="); uart_put_hex(frame->r1); uart_puts("\r\n");
    uart_puts("  PC="); uart_put_hex(frame->lr); uart_puts("\r\n");
    
    /* 简单处理：停止系统 */
    while(1) {
        asm volatile("wfi");
    }
}

/* 数据访问异常处理 */
void handle_data_abort(struct exception_frame *frame) {
    uint32_t fault_addr, fault_status;
    
    /* 读取故障地址寄存器 */
    asm volatile("mrc p15, 0, %0, c6, c0, 0" : "=r"(fault_addr));
    /* 读取故障状态寄存器 */
    asm volatile("mrc p15, 0, %0, c5, c0, 0" : "=r"(fault_status));
    
    uart_puts("*** DATA ABORT EXCEPTION ***\r\n");
    uart_puts("Fault Address: "); uart_put_hex(fault_addr); uart_puts("\r\n");
    uart_puts("Fault Status: "); uart_put_hex(fault_status); uart_puts("\r\n");
    uart_puts("PC: "); uart_put_hex(frame->lr); uart_puts("\r\n");
    
    while(1) {
        asm volatile("wfi");
    }
}

/* 预取指令异常处理 */
void handle_prefetch_abort(struct exception_frame *frame) {
    uart_puts("*** PREFETCH ABORT EXCEPTION ***\r\n");
    uart_puts("PC: "); uart_put_hex(frame->lr); uart_puts("\r\n");
    
    while(1) {
        asm volatile("wfi");
    }
}
```

### 实验2.2：实现定时器中断

#### 目标
配置ARM Generic Timer，实现周期性定时器中断。

#### 步骤

**1. 定时器配置 (kernel/timer.c)**

```c
#include <stdint.h>
#include "timer.h"
#include "uart.h"

/* ARM Generic Timer寄存器访问 */
static inline uint64_t read_cntfrq(void) {
    uint32_t freq;
    asm volatile("mrc p15, 0, %0, c14, c0, 0" : "=r"(freq));
    return freq;
}

static inline uint64_t read_cntp_tval(void) {
    uint32_t tval;
    asm volatile("mrc p15, 0, %0, c14, c2, 0" : "=r"(tval));
    return tval;
}

static inline void write_cntp_tval(uint32_t tval) {
    asm volatile("mcr p15, 0, %0, c14, c2, 0" : : "r"(tval));
}

static inline uint32_t read_cntp_ctl(void) {
    uint32_t ctl;
    asm volatile("mrc p15, 0, %0, c14, c2, 1" : "=r"(ctl));
    return ctl;
}

static inline void write_cntp_ctl(uint32_t ctl) {
    asm volatile("mcr p15, 0, %0, c14, c2, 1" : : "r"(ctl));
}

/* 全局变量 */
static uint32_t timer_frequency;
static volatile uint32_t timer_ticks = 0;

/* 初始化定时器 */
void timer_init(void) {
    /* 读取定时器频率 */
    timer_frequency = read_cntfrq();
    
    uart_puts("Timer frequency: ");
    uart_put_hex(timer_frequency);
    uart_puts(" Hz\r\n");
    
    /* 设置定时器中断间隔 (例如：10ms = frequency/100) */
    uint32_t interval = timer_frequency / 100;  // 10ms
    write_cntp_tval(interval);
    
    /* 启用定时器中断 */
    write_cntp_ctl(1);  // ENABLE bit = 1
    
    uart_puts("Timer initialized\r\n");
}

/* 定时器中断处理函数 */
void handle_timer_interrupt(void) {
    timer_ticks++;
    
    /* 重新设置下次中断时间 */
    uint32_t interval = timer_frequency / 100;  // 10ms
    write_cntp_tval(interval);
    
    /* 每秒输出一次时间信息 */
    if (timer_ticks % 100 == 0) {
        uart_puts("Timer tick: ");
        uart_put_hex(timer_ticks);
        uart_puts(" (");
        uart_put_hex(timer_ticks / 100);
        uart_puts(" seconds)\r\n");
    }
}

/* 获取当前滴答数 */
uint32_t get_timer_ticks(void) {
    return timer_ticks;
}
```

**2. GIC配置 (kernel/gic.c)**

```c
#include <stdint.h>
#include "gic.h"

/* QEMU virt machine GIC地址 */
#define GIC_DIST_BASE   0x08000000  /* 分发器基址 */
#define GIC_CPU_BASE    0x08010000  /* CPU接口基址 */

/* GIC分发器寄存器偏移 */
#define GICD_CTLR       0x000  /* 控制寄存器 */
#define GICD_TYPER      0x004  /* 类型寄存器 */
#define GICD_ISENABLER  0x100  /* 中断使能寄存器 */
#define GICD_ICENABLER  0x180  /* 中断禁用寄存器 */
#define GICD_IPRIORITYR 0x400  /* 中断优先级寄存器 */
#define GICD_ITARGETSR  0x800  /* 中断目标寄存器 */
#define GICD_ICFGR      0xC00  /* 中断配置寄存器 */

/* GIC CPU接口寄存器偏移 */
#define GICC_CTLR       0x000  /* 控制寄存器 */
#define GICC_PMR        0x004  /* 优先级屏蔽寄存器 */
#define GICC_IAR        0x00C  /* 中断确认寄存器 */
#define GICC_EOIR       0x010  /* 中断结束寄存器 */

/* 寄存器访问宏 */
#define GIC_DIST_REG(offset) (*(volatile uint32_t*)(GIC_DIST_BASE + (offset)))
#define GIC_CPU_REG(offset)  (*(volatile uint32_t*)(GIC_CPU_BASE + (offset)))

/* 定时器中断ID */
#define TIMER_IRQ_ID    30  /* ARM Generic Timer Physical Timer */

/* 初始化GIC */
void gic_init(void) {
    /* 禁用分发器 */
    GIC_DIST_REG(GICD_CTLR) = 0;
    
    /* 禁用CPU接口 */
    GIC_CPU_REG(GICC_CTLR) = 0;
    
    /* 设置定时器中断优先级 */
    uint32_t priority_reg = GICD_IPRIORITYR + (TIMER_IRQ_ID / 4) * 4;
    uint32_t priority_shift = (TIMER_IRQ_ID % 4) * 8;
    uint32_t priority_val = GIC_DIST_REG(priority_reg);
    priority_val &= ~(0xFF << priority_shift);
    priority_val |= (0x80 << priority_shift);  /* 中等优先级 */
    GIC_DIST_REG(priority_reg) = priority_val;
    
    /* 设置定时器中断目标CPU */
    uint32_t target_reg = GICD_ITARGETSR + (TIMER_IRQ_ID / 4) * 4;
    uint32_t target_shift = (TIMER_IRQ_ID % 4) * 8;
    uint32_t target_val = GIC_DIST_REG(target_reg);
    target_val &= ~(0xFF << target_shift);
    target_val |= (0x01 << target_shift);  /* 目标CPU 0 */
    GIC_DIST_REG(target_reg) = target_val;
    
    /* 使能定时器中断 */
    uint32_t enable_reg = GICD_ISENABLER + (TIMER_IRQ_ID / 32) * 4;
    uint32_t enable_bit = TIMER_IRQ_ID % 32;
    GIC_DIST_REG(enable_reg) = (1 << enable_bit);
    
    /* 启用分发器 */
    GIC_DIST_REG(GICD_CTLR) = 1;
    
    /* 设置CPU接口优先级屏蔽 */
    GIC_CPU_REG(GICC_PMR) = 0xFF;  /* 允许所有优先级 */
    
    /* 启用CPU接口 */
    GIC_CPU_REG(GICC_CTLR) = 1;
    
    uart_puts("GIC initialized\r\n");
}

/* IRQ中断处理 */
void handle_irq(void) {
    /* 读取中断确认寄存器，获取中断ID */
    uint32_t iar = GIC_CPU_REG(GICC_IAR);
    uint32_t irq_id = iar & 0x3FF;
    
    /* 处理定时器中断 */
    if (irq_id == TIMER_IRQ_ID) {
        handle_timer_interrupt();
    } else {
        uart_puts("Unknown IRQ: ");
        uart_put_hex(irq_id);
        uart_puts("\r\n");
    }
    
    /* 发送中断结束信号 */
    GIC_CPU_REG(GICC_EOIR) = iar;
}
```

### 实验2.3：系统调用机制

#### 目标
实现SVC异常处理，创建系统调用表和分发机制。

#### 步骤

**1. 系统调用表 (kernel/syscall.c)**

```c
#include <stdint.h>
#include "syscall.h"
#include "uart.h"

/* 系统调用号定义 */
#define SYS_WRITE   1
#define SYS_EXIT    2
#define SYS_GETTIME 3

/* 系统调用参数结构 */
struct syscall_regs {
    uint32_t r0, r1, r2, r3, r4, r5, r6, r7;
    uint32_t r8, r9, r10, r11, r12;
    uint32_t lr;
};

/* 系统调用：写字符串 */
static uint32_t sys_write(uint32_t fd, const char *buf, uint32_t count) {
    if (fd == 1) {  /* stdout */
        for (uint32_t i = 0; i < count; i++) {
            uart_putc(buf[i]);
        }
        return count;
    }
    return -1;
}

/* 系统调用：退出程序 */
static uint32_t sys_exit(uint32_t exit_code) {
    uart_puts("Program exit with code: ");
    uart_put_hex(exit_code);
    uart_puts("\r\n");
    
    /* 简单实现：进入死循环 */
    while(1) {
        asm volatile("wfi");
    }
    return 0;
}

/* 系统调用：获取时间 */
static uint32_t sys_gettime(void) {
    extern uint32_t get_timer_ticks(void);
    return get_timer_ticks();
}

/* 系统调用表 */
typedef uint32_t (*syscall_func_t)(uint32_t, uint32_t, uint32_t, uint32_t);

static syscall_func_t syscall_table[] = {
    [0] = NULL,
    [SYS_WRITE] = (syscall_func_t)sys_write,
    [SYS_EXIT] = (syscall_func_t)sys_exit,
    [SYS_GETTIME] = (syscall_func_t)sys_gettime,
};

#define SYSCALL_COUNT (sizeof(syscall_table) / sizeof(syscall_table[0]))

/* SVC异常处理函数 */
void handle_swi(uint32_t syscall_num, struct syscall_regs *regs) {
    uint32_t result = -1;
    
    if (syscall_num < SYSCALL_COUNT && syscall_table[syscall_num] != NULL) {
        /* 调用对应的系统调用函数 */
        result = syscall_table[syscall_num](regs->r0, regs->r1, regs->r2, regs->r3);
    } else {
        uart_puts("Unknown system call: ");
        uart_put_hex(syscall_num);
        uart_puts("\r\n");
    }
    
    /* 将返回值放入r0寄存器 */
    regs->r0 = result;
}
```

**2. 用户程序示例 (kernel/user_test.c)**

```c
/* 用户程序测试代码 */
static inline uint32_t syscall(uint32_t num, uint32_t arg1, uint32_t arg2, uint32_t arg3) {
    uint32_t result;
    
    asm volatile(
        "mov r0, %1\n"     /* 系统调用号 */
        "mov r1, %2\n"     /* 参数1 */
        "mov r2, %3\n"     /* 参数2 */
        "mov r3, %4\n"     /* 参数3 */
        "svc #0\n"         /* 触发系统调用 */
        "mov %0, r0\n"     /* 获取返回值 */
        : "=r"(result)
        : "r"(num), "r"(arg1), "r"(arg2), "r"(arg3)
        : "r0", "r1", "r2", "r3"
    );
    
    return result;
}

/* 测试系统调用 */
void test_syscalls(void) {
    const char *msg = "Hello from user program!\r\n";
    
    /* 测试写系统调用 */
    syscall(1, 1, (uint32_t)msg, 26);
    
    /* 测试获取时间系统调用 */
    uint32_t time = syscall(3, 0, 0, 0);
    uart_puts("Current time: ");
    uart_put_hex(time);
    uart_puts("\r\n");
}
```

### 实验2.4：集成和测试

#### 目标
集成所有组件，验证异常处理和中断系统的正确性。

#### 步骤

**1. 更新主函数 (kernel/main.c)**

```c
#include <stdint.h>
#include "uart.h"
#include "timer.h"
#include "gic.h"

extern void test_syscalls(void);
extern void enable_irq(void);  /* 在汇编中实现 */

int main(void) {
    /* 阶段1的初始化保持不变 */
    uart_puts("\r\n");
    uart_puts("======================================\r\n");
    uart_puts("    SkyOS - 阶段2：异常处理与中断\r\n");
    uart_puts("======================================\r\n");
    
    /* 初始化中断控制器 */
    gic_init();
    
    /* 初始化定时器 */
    timer_init();
    
    /* 启用IRQ中断 */
    enable_irq();
    
    uart_puts("异常处理和中断系统初始化完成\r\n");
    uart_puts("======================================\r\n");
    
    /* 测试系统调用 */
    uart_puts("测试系统调用:\r\n");
    test_syscalls();
    
    /* 主循环 */
    uint32_t counter = 0;
    while (1) {
        /* 每隔一段时间输出心跳 */
        for (volatile uint32_t i = 0; i < 5000000; i++);
        
        uart_puts("主程序心跳 #");
        uart_put_hex(counter++);
        uart_puts("\r\n");
    }
    
    return 0;
}
```

**2. 添加中断使能函数 (boot/start.S)**

```assembly
.global enable_irq
enable_irq:
    mrs r0, cpsr
    bic r0, r0, #0x80    @ 清除IRQ禁用位
    msr cpsr_c, r0
    bx lr

.global disable_irq
disable_irq:
    mrs r0, cpsr
    orr r0, r0, #0x80    @ 设置IRQ禁用位
    msr cpsr_c, r0
    bx lr
```

## 📊 预期实验结果

成功运行后应该看到：

```
======================================
    SkyOS - 阶段2：异常处理与中断
======================================
GIC initialized
Timer frequency: 0x3B9ACA00 Hz
Timer initialized
异常处理和中断系统初始化完成
======================================
测试系统调用:
Hello from user program!
Current time: 0x00000012
主程序心跳 #0x00000000
Timer tick: 0x00000064 (0x00000001 seconds)
主程序心跳 #0x00000001
Timer tick: 0x000000C8 (0x00000002 seconds)
主程序心跳 #0x00000002
...
```

## 🔍 调试和验证

### 异常测试

可以故意触发异常来测试异常处理：

```c
/* 测试未定义指令异常 */
void test_undefined_instruction(void) {
    asm volatile(".word 0xFFFFFFFF");  /* 未定义指令 */
}

/* 测试数据访问异常 */
void test_data_abort(void) {
    volatile uint32_t *invalid_ptr = (uint32_t*)0xFFFFFFFF;
    *invalid_ptr = 0x12345678;  /* 访问无效地址 */
}
```

### 性能测量

使用定时器测量中断处理性能：

```c
void measure_interrupt_latency(void) {
    /* 记录中断进入时间 */
    uint64_t start_time = read_cntvct();
    
    /* 中断处理逻辑 */
    handle_timer_interrupt();
    
    /* 记录中断退出时间 */
    uint64_t end_time = read_cntvct();
    
    uint32_t latency = (uint32_t)(end_time - start_time);
    uart_puts("Interrupt latency: ");
    uart_put_hex(latency);
    uart_puts(" cycles\r\n");
}
```

## 🎯 实验总结

通过本实验，学生将：

1. ✅ 掌握ARM异常处理的完整流程
2. ✅ 理解GIC中断控制器的编程方法
3. ✅ 实现定时器中断和系统调用机制
4. ✅ 具备调试和优化中断系统的能力

这为后续的内存管理和进程调度打下了坚实基础。 