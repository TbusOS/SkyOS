# å®éªŒ02ï¼šARMå¼‚å¸¸å¤„ç†ä¸ä¸­æ–­

## ğŸ“‹ å®éªŒæ¦‚è¿°

æœ¬å®éªŒå°†åœ¨é˜¶æ®µ1çš„åŸºç¡€ä¸Šï¼Œå®ç°å®Œæ•´çš„ARMå¼‚å¸¸å¤„ç†æœºåˆ¶å’Œä¸­æ–­æ§åˆ¶ç³»ç»Ÿï¼ŒåŒ…æ‹¬å¼‚å¸¸å‘é‡è¡¨ã€å®šæ—¶å™¨ä¸­æ–­ã€ç³»ç»Ÿè°ƒç”¨ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

## ğŸ¯ å®éªŒç›®æ ‡

1. å®ç°å®Œæ•´çš„ARMå¼‚å¸¸å‘é‡è¡¨å’Œå¤„ç†ç¨‹åº
2. é…ç½®å’Œä½¿ç”¨ARM Generic Timeräº§ç”Ÿå®šæ—¶å™¨ä¸­æ–­
3. å®ç°ç³»ç»Ÿè°ƒç”¨æœºåˆ¶
4. ç†è§£å’Œé…ç½®GICä¸­æ–­æ§åˆ¶å™¨
5. éªŒè¯å¼‚å¸¸å¤„ç†çš„æ­£ç¡®æ€§å’Œç¨³å®šæ€§

## ğŸ› ï¸ å®éªŒç¯å¢ƒ

- åŸºäºé˜¶æ®µ1çš„SkyOSå†…æ ¸
- QEMU virt machine (ARM Cortex-A15)
- ARM GIC v2ä¸­æ–­æ§åˆ¶å™¨
- ARM Generic Timer

## ğŸ“‚ å®éªŒå†…å®¹

### å®éªŒ2.1ï¼šå®Œå–„å¼‚å¸¸å‘é‡è¡¨

#### ç›®æ ‡
å®ç°å®Œæ•´çš„å¼‚å¸¸å¤„ç†æ¡†æ¶ï¼Œèƒ½å¤Ÿå¤„ç†å„ç§ARMå¼‚å¸¸ã€‚

#### æ­¥éª¤

**1. å¢å¼ºå¼‚å¸¸å‘é‡è¡¨ (boot/start.S)**

åœ¨åŸæœ‰åŸºç¡€ä¸Šå¢åŠ å®Œæ•´çš„å¼‚å¸¸å¤„ç†ç¨‹åºï¼š

```assembly
/*
 * å®Œæ•´çš„å¼‚å¸¸å¤„ç†ç¨‹åºæ¡†æ¶
 * æ¯ä¸ªå¼‚å¸¸éƒ½æœ‰ç‹¬ç«‹çš„å¤„ç†ç¨‹åº
 */

undef_handler:
    @ ä¿å­˜ä¸Šä¸‹æ–‡
    stmfd sp!, {r0-r12, lr}
    
    @ è°ƒç”¨Cè¯­è¨€å¼‚å¸¸å¤„ç†å‡½æ•°
    bl handle_undefined_instruction
    
    @ æ¢å¤ä¸Šä¸‹æ–‡å¹¶è¿”å›
    ldmfd sp!, {r0-r12, pc}^

swi_handler:
    @ ä¿å­˜ä¸Šä¸‹æ–‡ (æ³¨æ„ï¼šSVCæ¨¡å¼ä¸‹lræŒ‡å‘è¿”å›åœ°å€)
    stmfd sp!, {r0-r12, lr}
    
    @ è·å–SVCæŒ‡ä»¤ä¸­çš„ç«‹å³æ•°
    ldr r0, [lr, #-4]
    bic r0, r0, #0xFF000000
    
    @ ä»æ ˆä¸­è·å–å¯„å­˜å™¨å‚æ•°
    mov r1, sp
    
    @ è°ƒç”¨ç³»ç»Ÿè°ƒç”¨å¤„ç†å‡½æ•°
    bl handle_swi
    
    @ æ¢å¤ä¸Šä¸‹æ–‡å¹¶è¿”å›
    ldmfd sp!, {r0-r12, pc}^

prefetch_handler:
    stmfd sp!, {r0-r12, lr}
    bl handle_prefetch_abort
    ldmfd sp!, {r0-r12, pc}^

data_handler:
    stmfd sp!, {r0-r12, lr}
    bl handle_data_abort
    ldmfd sp!, {r0-r12, pc}^

irq_handler:
    @ ä¿å­˜ä¸Šä¸‹æ–‡åˆ°IRQæ¨¡å¼æ ˆ
    sub lr, lr, #4          @ è°ƒæ•´è¿”å›åœ°å€
    stmfd sp!, {r0-r12, lr}
    
    @ è°ƒç”¨Cè¯­è¨€IRQå¤„ç†å‡½æ•°
    bl handle_irq
    
    @ æ¢å¤ä¸Šä¸‹æ–‡å¹¶è¿”å›
    ldmfd sp!, {r0-r12, pc}^

fiq_handler:
    @ FIQæœ‰ç‹¬ç«‹çš„å¯„å­˜å™¨ç»„ï¼Œå¤„ç†æ›´å¿«
    stmfd sp!, {r0-r7, lr}
    bl handle_fiq
    ldmfd sp!, {r0-r7, pc}^
```

**2. åˆ›å»ºå¼‚å¸¸å¤„ç†Cå‡½æ•° (kernel/exception.c)**

```c
#include <stdint.h>
#include "uart.h"

/* å¼‚å¸¸ä¿¡æ¯ç»“æ„ */
struct exception_frame {
    uint32_t r0, r1, r2, r3, r4, r5, r6, r7;
    uint32_t r8, r9, r10, r11, r12;
    uint32_t lr;
};

/* æœªå®šä¹‰æŒ‡ä»¤å¼‚å¸¸å¤„ç† */
void handle_undefined_instruction(struct exception_frame *frame) {
    uart_puts("*** UNDEFINED INSTRUCTION EXCEPTION ***\r\n");
    uart_puts("Registers:\r\n");
    uart_puts("  R0="); uart_put_hex(frame->r0); uart_puts("\r\n");
    uart_puts("  R1="); uart_put_hex(frame->r1); uart_puts("\r\n");
    uart_puts("  PC="); uart_put_hex(frame->lr); uart_puts("\r\n");
    
    /* ç®€å•å¤„ç†ï¼šåœæ­¢ç³»ç»Ÿ */
    while(1) {
        asm volatile("wfi");
    }
}

/* æ•°æ®è®¿é—®å¼‚å¸¸å¤„ç† */
void handle_data_abort(struct exception_frame *frame) {
    uint32_t fault_addr, fault_status;
    
    /* è¯»å–æ•…éšœåœ°å€å¯„å­˜å™¨ */
    asm volatile("mrc p15, 0, %0, c6, c0, 0" : "=r"(fault_addr));
    /* è¯»å–æ•…éšœçŠ¶æ€å¯„å­˜å™¨ */
    asm volatile("mrc p15, 0, %0, c5, c0, 0" : "=r"(fault_status));
    
    uart_puts("*** DATA ABORT EXCEPTION ***\r\n");
    uart_puts("Fault Address: "); uart_put_hex(fault_addr); uart_puts("\r\n");
    uart_puts("Fault Status: "); uart_put_hex(fault_status); uart_puts("\r\n");
    uart_puts("PC: "); uart_put_hex(frame->lr); uart_puts("\r\n");
    
    while(1) {
        asm volatile("wfi");
    }
}

/* é¢„å–æŒ‡ä»¤å¼‚å¸¸å¤„ç† */
void handle_prefetch_abort(struct exception_frame *frame) {
    uart_puts("*** PREFETCH ABORT EXCEPTION ***\r\n");
    uart_puts("PC: "); uart_put_hex(frame->lr); uart_puts("\r\n");
    
    while(1) {
        asm volatile("wfi");
    }
}
```

### å®éªŒ2.2ï¼šå®ç°å®šæ—¶å™¨ä¸­æ–­

#### ç›®æ ‡
é…ç½®ARM Generic Timerï¼Œå®ç°å‘¨æœŸæ€§å®šæ—¶å™¨ä¸­æ–­ã€‚

#### æ­¥éª¤

**1. å®šæ—¶å™¨é…ç½® (kernel/timer.c)**

```c
#include <stdint.h>
#include "timer.h"
#include "uart.h"

/* ARM Generic Timerå¯„å­˜å™¨è®¿é—® */
static inline uint64_t read_cntfrq(void) {
    uint32_t freq;
    asm volatile("mrc p15, 0, %0, c14, c0, 0" : "=r"(freq));
    return freq;
}

static inline uint64_t read_cntp_tval(void) {
    uint32_t tval;
    asm volatile("mrc p15, 0, %0, c14, c2, 0" : "=r"(tval));
    return tval;
}

static inline void write_cntp_tval(uint32_t tval) {
    asm volatile("mcr p15, 0, %0, c14, c2, 0" : : "r"(tval));
}

static inline uint32_t read_cntp_ctl(void) {
    uint32_t ctl;
    asm volatile("mrc p15, 0, %0, c14, c2, 1" : "=r"(ctl));
    return ctl;
}

static inline void write_cntp_ctl(uint32_t ctl) {
    asm volatile("mcr p15, 0, %0, c14, c2, 1" : : "r"(ctl));
}

/* å…¨å±€å˜é‡ */
static uint32_t timer_frequency;
static volatile uint32_t timer_ticks = 0;

/* åˆå§‹åŒ–å®šæ—¶å™¨ */
void timer_init(void) {
    /* è¯»å–å®šæ—¶å™¨é¢‘ç‡ */
    timer_frequency = read_cntfrq();
    
    uart_puts("Timer frequency: ");
    uart_put_hex(timer_frequency);
    uart_puts(" Hz\r\n");
    
    /* è®¾ç½®å®šæ—¶å™¨ä¸­æ–­é—´éš” (ä¾‹å¦‚ï¼š10ms = frequency/100) */
    uint32_t interval = timer_frequency / 100;  // 10ms
    write_cntp_tval(interval);
    
    /* å¯ç”¨å®šæ—¶å™¨ä¸­æ–­ */
    write_cntp_ctl(1);  // ENABLE bit = 1
    
    uart_puts("Timer initialized\r\n");
}

/* å®šæ—¶å™¨ä¸­æ–­å¤„ç†å‡½æ•° */
void handle_timer_interrupt(void) {
    timer_ticks++;
    
    /* é‡æ–°è®¾ç½®ä¸‹æ¬¡ä¸­æ–­æ—¶é—´ */
    uint32_t interval = timer_frequency / 100;  // 10ms
    write_cntp_tval(interval);
    
    /* æ¯ç§’è¾“å‡ºä¸€æ¬¡æ—¶é—´ä¿¡æ¯ */
    if (timer_ticks % 100 == 0) {
        uart_puts("Timer tick: ");
        uart_put_hex(timer_ticks);
        uart_puts(" (");
        uart_put_hex(timer_ticks / 100);
        uart_puts(" seconds)\r\n");
    }
}

/* è·å–å½“å‰æ»´ç­”æ•° */
uint32_t get_timer_ticks(void) {
    return timer_ticks;
}
```

**2. GICé…ç½® (kernel/gic.c)**

```c
#include <stdint.h>
#include "gic.h"

/* QEMU virt machine GICåœ°å€ */
#define GIC_DIST_BASE   0x08000000  /* åˆ†å‘å™¨åŸºå€ */
#define GIC_CPU_BASE    0x08010000  /* CPUæ¥å£åŸºå€ */

/* GICåˆ†å‘å™¨å¯„å­˜å™¨åç§» */
#define GICD_CTLR       0x000  /* æ§åˆ¶å¯„å­˜å™¨ */
#define GICD_TYPER      0x004  /* ç±»å‹å¯„å­˜å™¨ */
#define GICD_ISENABLER  0x100  /* ä¸­æ–­ä½¿èƒ½å¯„å­˜å™¨ */
#define GICD_ICENABLER  0x180  /* ä¸­æ–­ç¦ç”¨å¯„å­˜å™¨ */
#define GICD_IPRIORITYR 0x400  /* ä¸­æ–­ä¼˜å…ˆçº§å¯„å­˜å™¨ */
#define GICD_ITARGETSR  0x800  /* ä¸­æ–­ç›®æ ‡å¯„å­˜å™¨ */
#define GICD_ICFGR      0xC00  /* ä¸­æ–­é…ç½®å¯„å­˜å™¨ */

/* GIC CPUæ¥å£å¯„å­˜å™¨åç§» */
#define GICC_CTLR       0x000  /* æ§åˆ¶å¯„å­˜å™¨ */
#define GICC_PMR        0x004  /* ä¼˜å…ˆçº§å±è”½å¯„å­˜å™¨ */
#define GICC_IAR        0x00C  /* ä¸­æ–­ç¡®è®¤å¯„å­˜å™¨ */
#define GICC_EOIR       0x010  /* ä¸­æ–­ç»“æŸå¯„å­˜å™¨ */

/* å¯„å­˜å™¨è®¿é—®å® */
#define GIC_DIST_REG(offset) (*(volatile uint32_t*)(GIC_DIST_BASE + (offset)))
#define GIC_CPU_REG(offset)  (*(volatile uint32_t*)(GIC_CPU_BASE + (offset)))

/* å®šæ—¶å™¨ä¸­æ–­ID */
#define TIMER_IRQ_ID    30  /* ARM Generic Timer Physical Timer */

/* åˆå§‹åŒ–GIC */
void gic_init(void) {
    /* ç¦ç”¨åˆ†å‘å™¨ */
    GIC_DIST_REG(GICD_CTLR) = 0;
    
    /* ç¦ç”¨CPUæ¥å£ */
    GIC_CPU_REG(GICC_CTLR) = 0;
    
    /* è®¾ç½®å®šæ—¶å™¨ä¸­æ–­ä¼˜å…ˆçº§ */
    uint32_t priority_reg = GICD_IPRIORITYR + (TIMER_IRQ_ID / 4) * 4;
    uint32_t priority_shift = (TIMER_IRQ_ID % 4) * 8;
    uint32_t priority_val = GIC_DIST_REG(priority_reg);
    priority_val &= ~(0xFF << priority_shift);
    priority_val |= (0x80 << priority_shift);  /* ä¸­ç­‰ä¼˜å…ˆçº§ */
    GIC_DIST_REG(priority_reg) = priority_val;
    
    /* è®¾ç½®å®šæ—¶å™¨ä¸­æ–­ç›®æ ‡CPU */
    uint32_t target_reg = GICD_ITARGETSR + (TIMER_IRQ_ID / 4) * 4;
    uint32_t target_shift = (TIMER_IRQ_ID % 4) * 8;
    uint32_t target_val = GIC_DIST_REG(target_reg);
    target_val &= ~(0xFF << target_shift);
    target_val |= (0x01 << target_shift);  /* ç›®æ ‡CPU 0 */
    GIC_DIST_REG(target_reg) = target_val;
    
    /* ä½¿èƒ½å®šæ—¶å™¨ä¸­æ–­ */
    uint32_t enable_reg = GICD_ISENABLER + (TIMER_IRQ_ID / 32) * 4;
    uint32_t enable_bit = TIMER_IRQ_ID % 32;
    GIC_DIST_REG(enable_reg) = (1 << enable_bit);
    
    /* å¯ç”¨åˆ†å‘å™¨ */
    GIC_DIST_REG(GICD_CTLR) = 1;
    
    /* è®¾ç½®CPUæ¥å£ä¼˜å…ˆçº§å±è”½ */
    GIC_CPU_REG(GICC_PMR) = 0xFF;  /* å…è®¸æ‰€æœ‰ä¼˜å…ˆçº§ */
    
    /* å¯ç”¨CPUæ¥å£ */
    GIC_CPU_REG(GICC_CTLR) = 1;
    
    uart_puts("GIC initialized\r\n");
}

/* IRQä¸­æ–­å¤„ç† */
void handle_irq(void) {
    /* è¯»å–ä¸­æ–­ç¡®è®¤å¯„å­˜å™¨ï¼Œè·å–ä¸­æ–­ID */
    uint32_t iar = GIC_CPU_REG(GICC_IAR);
    uint32_t irq_id = iar & 0x3FF;
    
    /* å¤„ç†å®šæ—¶å™¨ä¸­æ–­ */
    if (irq_id == TIMER_IRQ_ID) {
        handle_timer_interrupt();
    } else {
        uart_puts("Unknown IRQ: ");
        uart_put_hex(irq_id);
        uart_puts("\r\n");
    }
    
    /* å‘é€ä¸­æ–­ç»“æŸä¿¡å· */
    GIC_CPU_REG(GICC_EOIR) = iar;
}
```

### å®éªŒ2.3ï¼šç³»ç»Ÿè°ƒç”¨æœºåˆ¶

#### ç›®æ ‡
å®ç°SVCå¼‚å¸¸å¤„ç†ï¼Œåˆ›å»ºç³»ç»Ÿè°ƒç”¨è¡¨å’Œåˆ†å‘æœºåˆ¶ã€‚

#### æ­¥éª¤

**1. ç³»ç»Ÿè°ƒç”¨è¡¨ (kernel/syscall.c)**

```c
#include <stdint.h>
#include "syscall.h"
#include "uart.h"

/* ç³»ç»Ÿè°ƒç”¨å·å®šä¹‰ */
#define SYS_WRITE   1
#define SYS_EXIT    2
#define SYS_GETTIME 3

/* ç³»ç»Ÿè°ƒç”¨å‚æ•°ç»“æ„ */
struct syscall_regs {
    uint32_t r0, r1, r2, r3, r4, r5, r6, r7;
    uint32_t r8, r9, r10, r11, r12;
    uint32_t lr;
};

/* ç³»ç»Ÿè°ƒç”¨ï¼šå†™å­—ç¬¦ä¸² */
static uint32_t sys_write(uint32_t fd, const char *buf, uint32_t count) {
    if (fd == 1) {  /* stdout */
        for (uint32_t i = 0; i < count; i++) {
            uart_putc(buf[i]);
        }
        return count;
    }
    return -1;
}

/* ç³»ç»Ÿè°ƒç”¨ï¼šé€€å‡ºç¨‹åº */
static uint32_t sys_exit(uint32_t exit_code) {
    uart_puts("Program exit with code: ");
    uart_put_hex(exit_code);
    uart_puts("\r\n");
    
    /* ç®€å•å®ç°ï¼šè¿›å…¥æ­»å¾ªç¯ */
    while(1) {
        asm volatile("wfi");
    }
    return 0;
}

/* ç³»ç»Ÿè°ƒç”¨ï¼šè·å–æ—¶é—´ */
static uint32_t sys_gettime(void) {
    extern uint32_t get_timer_ticks(void);
    return get_timer_ticks();
}

/* ç³»ç»Ÿè°ƒç”¨è¡¨ */
typedef uint32_t (*syscall_func_t)(uint32_t, uint32_t, uint32_t, uint32_t);

static syscall_func_t syscall_table[] = {
    [0] = NULL,
    [SYS_WRITE] = (syscall_func_t)sys_write,
    [SYS_EXIT] = (syscall_func_t)sys_exit,
    [SYS_GETTIME] = (syscall_func_t)sys_gettime,
};

#define SYSCALL_COUNT (sizeof(syscall_table) / sizeof(syscall_table[0]))

/* SVCå¼‚å¸¸å¤„ç†å‡½æ•° */
void handle_swi(uint32_t syscall_num, struct syscall_regs *regs) {
    uint32_t result = -1;
    
    if (syscall_num < SYSCALL_COUNT && syscall_table[syscall_num] != NULL) {
        /* è°ƒç”¨å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å‡½æ•° */
        result = syscall_table[syscall_num](regs->r0, regs->r1, regs->r2, regs->r3);
    } else {
        uart_puts("Unknown system call: ");
        uart_put_hex(syscall_num);
        uart_puts("\r\n");
    }
    
    /* å°†è¿”å›å€¼æ”¾å…¥r0å¯„å­˜å™¨ */
    regs->r0 = result;
}
```

**2. ç”¨æˆ·ç¨‹åºç¤ºä¾‹ (kernel/user_test.c)**

```c
/* ç”¨æˆ·ç¨‹åºæµ‹è¯•ä»£ç  */
static inline uint32_t syscall(uint32_t num, uint32_t arg1, uint32_t arg2, uint32_t arg3) {
    uint32_t result;
    
    asm volatile(
        "mov r0, %1\n"     /* ç³»ç»Ÿè°ƒç”¨å· */
        "mov r1, %2\n"     /* å‚æ•°1 */
        "mov r2, %3\n"     /* å‚æ•°2 */
        "mov r3, %4\n"     /* å‚æ•°3 */
        "svc #0\n"         /* è§¦å‘ç³»ç»Ÿè°ƒç”¨ */
        "mov %0, r0\n"     /* è·å–è¿”å›å€¼ */
        : "=r"(result)
        : "r"(num), "r"(arg1), "r"(arg2), "r"(arg3)
        : "r0", "r1", "r2", "r3"
    );
    
    return result;
}

/* æµ‹è¯•ç³»ç»Ÿè°ƒç”¨ */
void test_syscalls(void) {
    const char *msg = "Hello from user program!\r\n";
    
    /* æµ‹è¯•å†™ç³»ç»Ÿè°ƒç”¨ */
    syscall(1, 1, (uint32_t)msg, 26);
    
    /* æµ‹è¯•è·å–æ—¶é—´ç³»ç»Ÿè°ƒç”¨ */
    uint32_t time = syscall(3, 0, 0, 0);
    uart_puts("Current time: ");
    uart_put_hex(time);
    uart_puts("\r\n");
}
```

### å®éªŒ2.4ï¼šé›†æˆå’Œæµ‹è¯•

#### ç›®æ ‡
é›†æˆæ‰€æœ‰ç»„ä»¶ï¼ŒéªŒè¯å¼‚å¸¸å¤„ç†å’Œä¸­æ–­ç³»ç»Ÿçš„æ­£ç¡®æ€§ã€‚

#### æ­¥éª¤

**1. æ›´æ–°ä¸»å‡½æ•° (kernel/main.c)**

```c
#include <stdint.h>
#include "uart.h"
#include "timer.h"
#include "gic.h"

extern void test_syscalls(void);
extern void enable_irq(void);  /* åœ¨æ±‡ç¼–ä¸­å®ç° */

int main(void) {
    /* é˜¶æ®µ1çš„åˆå§‹åŒ–ä¿æŒä¸å˜ */
    uart_puts("\r\n");
    uart_puts("======================================\r\n");
    uart_puts("    SkyOS - é˜¶æ®µ2ï¼šå¼‚å¸¸å¤„ç†ä¸ä¸­æ–­\r\n");
    uart_puts("======================================\r\n");
    
    /* åˆå§‹åŒ–ä¸­æ–­æ§åˆ¶å™¨ */
    gic_init();
    
    /* åˆå§‹åŒ–å®šæ—¶å™¨ */
    timer_init();
    
    /* å¯ç”¨IRQä¸­æ–­ */
    enable_irq();
    
    uart_puts("å¼‚å¸¸å¤„ç†å’Œä¸­æ–­ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ\r\n");
    uart_puts("======================================\r\n");
    
    /* æµ‹è¯•ç³»ç»Ÿè°ƒç”¨ */
    uart_puts("æµ‹è¯•ç³»ç»Ÿè°ƒç”¨:\r\n");
    test_syscalls();
    
    /* ä¸»å¾ªç¯ */
    uint32_t counter = 0;
    while (1) {
        /* æ¯éš”ä¸€æ®µæ—¶é—´è¾“å‡ºå¿ƒè·³ */
        for (volatile uint32_t i = 0; i < 5000000; i++);
        
        uart_puts("ä¸»ç¨‹åºå¿ƒè·³ #");
        uart_put_hex(counter++);
        uart_puts("\r\n");
    }
    
    return 0;
}
```

**2. æ·»åŠ ä¸­æ–­ä½¿èƒ½å‡½æ•° (boot/start.S)**

```assembly
.global enable_irq
enable_irq:
    mrs r0, cpsr
    bic r0, r0, #0x80    @ æ¸…é™¤IRQç¦ç”¨ä½
    msr cpsr_c, r0
    bx lr

.global disable_irq
disable_irq:
    mrs r0, cpsr
    orr r0, r0, #0x80    @ è®¾ç½®IRQç¦ç”¨ä½
    msr cpsr_c, r0
    bx lr
```

## ğŸ“Š é¢„æœŸå®éªŒç»“æœ

æˆåŠŸè¿è¡Œååº”è¯¥çœ‹åˆ°ï¼š

```
======================================
    SkyOS - é˜¶æ®µ2ï¼šå¼‚å¸¸å¤„ç†ä¸ä¸­æ–­
======================================
GIC initialized
Timer frequency: 0x3B9ACA00 Hz
Timer initialized
å¼‚å¸¸å¤„ç†å’Œä¸­æ–­ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ
======================================
æµ‹è¯•ç³»ç»Ÿè°ƒç”¨:
Hello from user program!
Current time: 0x00000012
ä¸»ç¨‹åºå¿ƒè·³ #0x00000000
Timer tick: 0x00000064 (0x00000001 seconds)
ä¸»ç¨‹åºå¿ƒè·³ #0x00000001
Timer tick: 0x000000C8 (0x00000002 seconds)
ä¸»ç¨‹åºå¿ƒè·³ #0x00000002
...
```

## ğŸ” è°ƒè¯•å’ŒéªŒè¯

### å¼‚å¸¸æµ‹è¯•

å¯ä»¥æ•…æ„è§¦å‘å¼‚å¸¸æ¥æµ‹è¯•å¼‚å¸¸å¤„ç†ï¼š

```c
/* æµ‹è¯•æœªå®šä¹‰æŒ‡ä»¤å¼‚å¸¸ */
void test_undefined_instruction(void) {
    asm volatile(".word 0xFFFFFFFF");  /* æœªå®šä¹‰æŒ‡ä»¤ */
}

/* æµ‹è¯•æ•°æ®è®¿é—®å¼‚å¸¸ */
void test_data_abort(void) {
    volatile uint32_t *invalid_ptr = (uint32_t*)0xFFFFFFFF;
    *invalid_ptr = 0x12345678;  /* è®¿é—®æ— æ•ˆåœ°å€ */
}
```

### æ€§èƒ½æµ‹é‡

ä½¿ç”¨å®šæ—¶å™¨æµ‹é‡ä¸­æ–­å¤„ç†æ€§èƒ½ï¼š

```c
void measure_interrupt_latency(void) {
    /* è®°å½•ä¸­æ–­è¿›å…¥æ—¶é—´ */
    uint64_t start_time = read_cntvct();
    
    /* ä¸­æ–­å¤„ç†é€»è¾‘ */
    handle_timer_interrupt();
    
    /* è®°å½•ä¸­æ–­é€€å‡ºæ—¶é—´ */
    uint64_t end_time = read_cntvct();
    
    uint32_t latency = (uint32_t)(end_time - start_time);
    uart_puts("Interrupt latency: ");
    uart_put_hex(latency);
    uart_puts(" cycles\r\n");
}
```

## ğŸ¯ å®éªŒæ€»ç»“

é€šè¿‡æœ¬å®éªŒï¼Œå­¦ç”Ÿå°†ï¼š

1. âœ… æŒæ¡ARMå¼‚å¸¸å¤„ç†çš„å®Œæ•´æµç¨‹
2. âœ… ç†è§£GICä¸­æ–­æ§åˆ¶å™¨çš„ç¼–ç¨‹æ–¹æ³•
3. âœ… å®ç°å®šæ—¶å™¨ä¸­æ–­å’Œç³»ç»Ÿè°ƒç”¨æœºåˆ¶
4. âœ… å…·å¤‡è°ƒè¯•å’Œä¼˜åŒ–ä¸­æ–­ç³»ç»Ÿçš„èƒ½åŠ›

è¿™ä¸ºåç»­çš„å†…å­˜ç®¡ç†å’Œè¿›ç¨‹è°ƒåº¦æ‰“ä¸‹äº†åšå®åŸºç¡€ã€‚ 