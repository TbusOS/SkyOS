# 实验01：ARM64启动与基础功能

## 📋 实验概述

本实验将带领学生理解ARM64处理器的启动流程，掌握ARM64汇编编程基础，并在QEMU虚拟机中运行一个简单的ARM64内核。

## 🎯 实验目标

1. 理解ARM64异常级别和寄存器组织
2. 掌握ARM64异常向量表的设置
3. 学习ARM64汇编语言编程
4. 实现基础的UART串口输出
5. 在QEMU中运行ARM64操作系统内核

## 🛠️ 实验环境

### 系统要求
- macOS (支持Homebrew)
- 命令行终端

### 工具安装
```bash
# 安装ARM64交叉编译工具链
brew install aarch64-elf-gcc

# 安装QEMU模拟器
brew install qemu

# 验证安装
aarch64-none-elf-gcc --version
qemu-system-aarch64 --version
```

## 📁 项目结构

```
stages/stage01-arm64/code/
├── Makefile          # 构建脚本
├── boot/
│   ├── start.S       # ARM64启动汇编代码
│   └── boot.lds      # 链接脚本
└── kernel/
    └── main.c        # C语言主函数
```

## 🔍 代码分析

### 1. 异常向量表 (boot/start.S)

ARM64异常向量表是处理器启动后的第一个执行点：

```assembly
_vectors:
    /* Current EL with SP_EL0 */
    .align 7
    b sync_current_el_sp0      // 0x000: Synchronous
    .align 7  
    b irq_current_el_sp0       // 0x080: IRQ
    .align 7
    b fiq_current_el_sp0       // 0x100: FIQ
    .align 7
    b serror_current_el_sp0    // 0x180: SError
```

**关键点**：
- 每个向量条目占128字节 (`.align 7` = 2^7 = 128)
- 16个向量条目，总共2KB
- 支持4种异常类型：同步、IRQ、FIQ、系统错误

### 2. 启动流程 (boot/start.S)

```assembly
_start:
    /* 禁用中断 */
    msr daifset, #0xf
    
    /* 设置异常向量表基址 */
    adr x0, _vectors
    msr vbar_el1, x0
    
    /* 设置堆栈指针 */
    adr x0, el1_stack_top
    mov sp, x0
```

**关键步骤**：
1. 禁用所有中断和异常
2. 设置异常向量表基址寄存器
3. 初始化堆栈指针
4. 清零BSS段
5. 跳转到C语言main函数

### 3. 内存布局 (boot/boot.lds)

```ld
MEMORY
{
    RAM (rwx) : ORIGIN = 0x40000000, LENGTH = 256M
}

SECTIONS
{
    . = 0x40000000;
    
    .vectors : { KEEP(*(.vectors)) } > RAM
    .text : { *(.text*) *(.rodata*) } > RAM
    .data : { *(.data*) } > RAM
    .bss : { __bss_start = .; *(.bss*) __bss_end = .; } > RAM
}
```

**关键配置**：
- 内核加载地址：0x40000000
- 异常向量表放在最前面
- 代码、数据、BSS段依次排列

### 4. 系统寄存器访问 (kernel/main.c)

```c
/* 获取ARM64处理器ID */
uint64_t get_processor_id(void) {
    uint64_t id;
    asm volatile("mrs %0, midr_el1" : "=r"(id));
    return id;
}

/* 获取当前异常级别 */
uint64_t get_current_el(void) {
    uint64_t el;
    asm volatile("mrs %0, currentel" : "=r"(el));
    return (el >> 2) & 3;
}
```

**重要寄存器**：
- MIDR_EL1: 处理器标识寄存器
- CurrentEL: 当前异常级别
- MPIDR_EL1: 多处理器亲和性
- SCTLR_EL1: 系统控制寄存器

## ⚡ 实验步骤

### 步骤1：环境验证
```bash
cd stages/stage01-arm64/code
make check-toolchain
```

### 步骤2：代码编译
```bash
make clean
make all
```

预期输出：
```
AS boot/start.S
CC kernel/main.c
LD build/skymos.elf
OBJCOPY build/skymos.bin
Creating kernel image...
```

### 步骤3：运行内核
```bash
make run
```

### 步骤4：调试分析
在另一个终端中：
```bash
# 生成反汇编
make disasm
cat build/skymos.disasm | head -50

# 查看符号表
make symbols
cat build/skymos.symbols
```

## 🔍 硬件规格探索

### QEMU virt machine硬件布局

运行时可以查看硬件信息：
```bash
# 查看设备树
qemu-system-aarch64 -machine virt -cpu cortex-a57 -machine dumpdtb=virt.dtb
dtc -I dtb -O dts virt.dtb

# 查看内存布局
(qemu) info mtree
```

### 关键硬件地址

| 设备 | 基址 | 大小 | 描述 |
|------|------|------|------|
| RAM | 0x40000000 | 256MB | 主内存 |
| UART0 | 0x09000000 | 4KB | PL011串口 |
| GIC | 0x08000000 | 64KB | 中断控制器 |
| GPIO | 0x09030000 | 4KB | GPIO控制器 |

## 📊 预期结果

运行成功后应该看到：

```
======================================
    SkymOS - ARM64 教学操作系统
======================================
版本: 0.1.0 (ARM64演示版)
架构: ARM Cortex-A57 (ARMv8-A)
平台: QEMU virt machine
编译时间: Aug 18 2024 01:50:00
--------------------------------------
处理器ID (MIDR_EL1): 0x411FD070
当前异常级别: EL1 (Kernel) (0x0000000000000001)
多处理器ID (MPIDR_EL1): 0x0000000080000000
系统控制寄存器 (SCTLR_EL1): 0x0000000030100180
--------------------------------------
ARM64特性检查:
  MMU状态: 禁用
  缓存状态: 禁用
  地址对齐检查: 禁用
--------------------------------------
内核初始化完成！
======================================

开始心跳显示 (按Ctrl+A X退出QEMU):
💓 心跳 #0000000000000000 - SkymOS ARM64 正在运行!
💓 心跳 #0000000000000001 - SkymOS ARM64 正在运行!
💓 心跳 #0000000000000002 - SkymOS ARM64 正在运行!
...
```

## 🤔 分析问题

### 1. 处理器信息解析

**MIDR_EL1寄存器** (0x411FD070):
- Implementer: 0x41 (ARM)
- Variant: 0x1
- Architecture: 0xF (ARMv8)
- PartNum: 0xD07 (Cortex-A57)
- Revision: 0x0

### 2. 异常级别分析

**CurrentEL寄存器**：
- 返回值 0x1 表示当前运行在EL1 (内核级别)
- 这是操作系统内核的正常执行级别

### 3. 系统控制寄存器

**SCTLR_EL1寄存器** (0x30100180):
- Bit 0 (M): 0 = MMU禁用
- Bit 1 (A): 0 = 对齐检查禁用
- Bit 2 (C): 0 = 数据缓存禁用
- 其他位为默认配置

## 🎯 实验任务

### 基础任务
1. ✅ 成功编译并运行ARM64内核
2. ✅ 理解异常向量表的结构
3. ✅ 分析处理器寄存器信息
4. ✅ 观察心跳输出

### 进阶任务
1. 修改心跳显示格式，添加时间戳
2. 实现一个简单的异常处理程序
3. 添加对更多系统寄存器的读取
4. 尝试修改内存布局地址

### 挑战任务
1. 启用MMU和缓存
2. 实现异常级别切换
3. 添加基础的中断处理
4. 移植到真实ARM64硬件

## ❓ 常见问题

**Q: 编译时提示找不到工具链？**
A: 确保已安装aarch64-elf-gcc，可能需要添加PATH。

**Q: QEMU启动后没有输出？**
A: 检查链接脚本中的内存地址是否正确。

**Q: 心跳显示异常？**
A: 检查UART初始化和延时函数实现。

**Q: 如何退出QEMU？**
A: 按Ctrl+A，然后按X。

## 📚 参考资料

1. [ARM Architecture Reference Manual ARMv8-A](https://developer.arm.com/documentation/ddi0487/)
2. [ARM Cortex-A57 Technical Reference Manual](https://developer.arm.com/documentation/ddi0488/)
3. [QEMU ARM System Emulation](https://www.qemu.org/docs/master/system/target-arm.html)
4. [ARM PL011 UART Technical Reference Manual](https://developer.arm.com/documentation/ddi0183/)

## 🏁 实验报告要求

请完成以下实验报告：

1. **实验环境**：描述你的开发环境和工具版本
2. **代码分析**：分析启动流程和关键代码段
3. **运行结果**：截图显示成功运行的输出
4. **寄存器分析**：解析MIDR_EL1等关键寄存器的含义
5. **问题总结**：遇到的问题和解决方案
6. **扩展思考**：对ARM64架构的理解和思考 