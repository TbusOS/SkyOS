# ARM64开发工具使用指南

## 🎯 文档目的

本文档提供ARM64开发所需的工具链安装、配置和使用方法，包括交叉编译器、调试器、QEMU模拟器等核心开发工具的详细使用指南。

## 🛠️ 工具链安装

### macOS环境 (推荐)

#### 使用Homebrew安装

```bash
# 更新Homebrew
brew update

# 安装ARM64交叉编译工具链
brew install aarch64-elf-gcc

# 安装QEMU模拟器
brew install qemu

# 安装设备树编译器
brew install dtc

# 安装其他有用工具
brew install binutils
brew install gdb
```

#### 验证安装

```bash
# 验证编译器
aarch64-none-elf-gcc --version
aarch64-none-elf-as --version
aarch64-none-elf-ld --version

# 验证QEMU
qemu-system-aarch64 --version

# 验证设备树编译器
dtc --version
```

### Linux环境

#### Ubuntu/Debian

```bash
# 更新包管理器
sudo apt update

# 安装ARM64工具链
sudo apt install gcc-aarch64-linux-gnu
sudo apt install binutils-aarch64-linux-gnu

# 安装QEMU
sudo apt install qemu-system-arm

# 安装设备树编译器
sudo apt install device-tree-compiler

# 安装GDB
sudo apt install gdb-multiarch
```

#### CentOS/RHEL

```bash
# 启用EPEL仓库
sudo yum install epel-release

# 安装工具链
sudo yum install gcc-aarch64-linux-gnu
sudo yum install qemu-system-aarch64

# 从源码编译dtc (如果包不可用)
git clone https://git.kernel.org/pub/scm/utils/dtc/dtc.git
cd dtc
make && sudo make install
```

## 🔧 交叉编译器详解

### ARM64-ELF工具链

```bash
# 编译器套件
aarch64-none-elf-gcc     # C/C++编译器
aarch64-none-elf-g++     # C++编译器
aarch64-none-elf-as      # 汇编器
aarch64-none-elf-ld      # 链接器
aarch64-none-elf-objcopy # 目标文件转换
aarch64-none-elf-objdump # 反汇编器
aarch64-none-elf-nm      # 符号查看器
aarch64-none-elf-size    # 大小分析器
aarch64-none-elf-strip   # 符号剥离器
```

### 编译器选项详解

#### CPU和架构选项

```bash
# 指定CPU型号
-mcpu=cortex-a57        # Cortex-A57
-mcpu=cortex-a72        # Cortex-A72
-mcpu=cortex-a73        # Cortex-A73
-mcpu=generic           # 通用ARM64

# 指定架构版本
-march=armv8-a          # ARMv8-A基础架构
-march=armv8.1-a        # ARMv8.1-A
-march=armv8.2-a        # ARMv8.2-A

# 指定调优目标
-mtune=cortex-a57       # 针对A57优化
-mtune=generic          # 通用优化
```

#### 代码生成选项

```bash
# 基础选项
-ffreestanding          # 独立环境编译
-nostdlib              # 不链接标准库
-nostartfiles          # 不使用默认启动文件

# 栈和安全选项
-fno-stack-protector   # 禁用栈保护
-fno-builtin           # 禁用内建函数
-fno-common           # 禁用通用块

# 优化选项
-O0                    # 无优化，便于调试
-O1                    # 基础优化
-O2                    # 标准优化（推荐）
-O3                    # 激进优化
-Os                    # 大小优化
```

#### 调试选项

```bash
# 调试信息
-g                     # 生成调试信息
-g3                    # 详细调试信息
-gdwarf-2             # DWARF2格式
-gdwarf-4             # DWARF4格式

# 警告选项
-Wall                  # 常见警告
-Wextra               # 额外警告
-Werror               # 警告当作错误
-Wpedantic            # 严格标准检查
```

### 链接器使用

#### 基本链接

```bash
# 基本链接命令
aarch64-none-elf-ld -T linker.lds -o output.elf input1.o input2.o

# 常用链接选项
-T script.lds          # 指定链接脚本
-nostdlib             # 不链接标准库
-static               # 静态链接
-Map=output.map       # 生成内存映射文件
```

#### 链接脚本示例

```ld
/* 完整的链接脚本示例 */
ENTRY(_start)

MEMORY
{
    ROM (rx)  : ORIGIN = 0x00000000, LENGTH = 1M
    RAM (rwx) : ORIGIN = 0x40000000, LENGTH = 256M
}

SECTIONS
{
    .text : {
        *(.vectors)
        *(.text*)
        *(.rodata*)
        . = ALIGN(8);
    } > RAM
    
    .data : {
        __data_start = .;
        *(.data*)
        __data_end = .;
        . = ALIGN(8);
    } > RAM
    
    .bss : {
        __bss_start = .;
        *(.bss*)
        *(COMMON)
        __bss_end = .;
        . = ALIGN(8);
    } > RAM
    
    /DISCARD/ : {
        *(.note*)
        *(.comment)
        *(.ARM.attributes)
    }
}
```

## 🖥️ QEMU使用详解

### 基本QEMU命令

```bash
# 基本启动命令
qemu-system-aarch64 -machine virt -cpu cortex-a57 -m 256M -nographic -kernel kernel.bin

# 参数说明
-machine virt          # 使用virt虚拟机
-cpu cortex-a57       # 指定CPU型号
-m 256M               # 内存大小
-nographic            # 无图形界面
-kernel kernel.bin    # 内核文件
```

### 高级QEMU选项

#### 调试选项

```bash
# GDB调试支持
qemu-system-aarch64 \
    -machine virt \
    -cpu cortex-a57 \
    -m 256M \
    -nographic \
    -kernel kernel.bin \
    -s \                  # GDB服务器端口1234
    -S                    # 启动时暂停

# 指定调试端口
qemu-system-aarch64 ... -gdb tcp::1234

# 监控模式
qemu-system-aarch64 ... -monitor stdio
```

#### 设备和外设

```bash
# 串口重定向
-serial stdio          # 串口输出到标准输入输出
-serial file:output.txt # 串口输出到文件
-serial tcp:localhost:4444,server # TCP串口服务器

# 存储设备
-drive file=disk.img,format=raw,if=virtio
-cdrom cdimage.iso

# 网络设备
-netdev user,id=net0 -device virtio-net-pci,netdev=net0
```

#### 信息查询

```bash
# 启动监控模式
qemu-system-aarch64 -monitor stdio

# 监控命令
(qemu) info registers    # 查看寄存器
(qemu) info memory       # 查看内存
(qemu) info mtree        # 查看内存树
(qemu) info qtree        # 查看设备树
(qemu) x/10x 0x40000000  # 查看内存内容
```

### 设备树生成和分析

```bash
# 生成设备树二进制文件
qemu-system-aarch64 -machine virt -cpu cortex-a57 -machine dumpdtb=virt.dtb

# 转换为文本格式
dtc -I dtb -O dts virt.dtb > virt.dts

# 分析设备树
grep -A 10 "compatible" virt.dts  # 查看兼容设备
grep -A 5 "reg = " virt.dts       # 查看寄存器地址
grep -A 5 "interrupts" virt.dts   # 查看中断配置
```

## 🐛 调试工具使用

### GDB调试

#### 启动调试会话

```bash
# 终端1: 启动QEMU调试模式
qemu-system-aarch64 -machine virt -cpu cortex-a57 -m 256M -nographic \
    -kernel kernel.elf -s -S

# 终端2: 启动GDB
aarch64-none-elf-gdb kernel.elf
```

#### GDB基本命令

```gdb
# 连接QEMU
(gdb) target remote localhost:1234

# 基本控制
(gdb) continue          # 继续执行
(gdb) step             # 单步执行
(gdb) next             # 下一行
(gdb) finish           # 执行到函数返回

# 断点管理
(gdb) break main       # 在main函数设置断点
(gdb) break *0x40000000 # 在地址设置断点
(gdb) info breakpoints # 查看断点
(gdb) delete 1         # 删除断点1

# 内存和寄存器
(gdb) info registers   # 查看所有寄存器
(gdb) print $x0        # 查看X0寄存器
(gdb) x/10x 0x40000000 # 查看内存
(gdb) set $x0 = 0x1234 # 设置寄存器值
```

#### ARM64特定调试

```gdb
# 查看ARM64寄存器
(gdb) info registers general    # 通用寄存器
(gdb) info registers system     # 系统寄存器
(gdb) info registers vector     # 向量寄存器

# 查看异常级别
(gdb) print/x $currentel

# 查看异常向量表
(gdb) print/x $vbar_el1

# 反汇编
(gdb) disassemble main
(gdb) disassemble $pc,$pc+40
```

### LLDB调试 (macOS)

```lldb
# 启动LLDB
lldb kernel.elf

# 连接QEMU
(lldb) gdb-remote localhost:1234

# 基本命令
(lldb) continue
(lldb) step
(lldb) next

# 断点
(lldb) breakpoint set --name main
(lldb) breakpoint set --address 0x40000000

# 寄存器和内存
(lldb) register read
(lldb) register read x0
(lldb) memory read 0x40000000
```

## 📊 分析工具

### 目标文件分析

```bash
# 查看目标文件信息
aarch64-none-elf-objdump -h kernel.elf     # 段信息
aarch64-none-elf-objdump -t kernel.elf     # 符号表
aarch64-none-elf-objdump -d kernel.elf     # 反汇编

# 查看文件大小
aarch64-none-elf-size kernel.elf

# 查看文件格式
file kernel.elf
aarch64-none-elf-readelf -h kernel.elf     # ELF头信息
```

### 性能分析

```bash
# 生成调用图
aarch64-none-elf-objdump -d kernel.elf | grep "bl\|b\..*" > calls.txt

# 分析代码大小
aarch64-none-elf-nm --size-sort kernel.elf | tail -20

# 检查栈使用
aarch64-none-elf-objdump -d kernel.elf | grep -E "(sub|add).*sp"
```

## 🔨 Makefile最佳实践

### 完整的Makefile示例

```makefile
# ARM64 项目 Makefile
ARCH := arm64
TARGET := aarch64-none-elf

# 工具链
CC := $(TARGET)-gcc
AS := $(TARGET)-as
LD := $(TARGET)-ld
OBJCOPY := $(TARGET)-objcopy
OBJDUMP := $(TARGET)-objdump
GDB := $(TARGET)-gdb

# 编译选项
CFLAGS := -mcpu=cortex-a57 -ffreestanding -nostdlib -nostartfiles
CFLAGS += -Wall -Wextra -g -O2 -fno-stack-protector
ASFLAGS := -mcpu=cortex-a57 -g
LDFLAGS := -T linker.lds -nostdlib

# 目录
SRCDIR := src
BUILDDIR := build
INCDIR := include

# 文件
SOURCES := $(wildcard $(SRCDIR)/*.c) $(wildcard $(SRCDIR)/*.S)
OBJECTS := $(SOURCES:$(SRCDIR)/%=$(BUILDDIR)/%.o)
TARGET_ELF := $(BUILDDIR)/kernel.elf
TARGET_BIN := $(BUILDDIR)/kernel.bin

# QEMU配置
QEMU := qemu-system-aarch64
QEMU_FLAGS := -machine virt -cpu cortex-a57 -m 256M -nographic
QEMU_DEBUG := $(QEMU_FLAGS) -s -S

# 默认目标
.PHONY: all clean run debug help

all: $(TARGET_BIN)

# 创建构建目录
$(BUILDDIR):
	mkdir -p $(BUILDDIR)

# 编译规则
$(BUILDDIR)/%.c.o: $(SRCDIR)/%.c | $(BUILDDIR)
	$(CC) $(CFLAGS) -I$(INCDIR) -c $< -o $@

$(BUILDDIR)/%.S.o: $(SRCDIR)/%.S | $(BUILDDIR)
	$(AS) $(ASFLAGS) -c $< -o $@

# 链接
$(TARGET_ELF): $(OBJECTS)
	$(LD) $(LDFLAGS) $^ -o $@

# 生成二进制
$(TARGET_BIN): $(TARGET_ELF)
	$(OBJCOPY) -O binary $< $@

# 运行
run: $(TARGET_BIN)
	$(QEMU) $(QEMU_FLAGS) -kernel $<

# 调试
debug: $(TARGET_ELF)
	@echo "Starting QEMU in debug mode..."
	@echo "In another terminal run: $(GDB) $<"
	@echo "Then connect with: target remote localhost:1234"
	$(QEMU) $(QEMU_DEBUG) -kernel $(TARGET_BIN)

# 反汇编
disasm: $(TARGET_ELF)
	$(OBJDUMP) -d $< > $(BUILDDIR)/kernel.disasm

# 清理
clean:
	rm -rf $(BUILDDIR)

# 帮助
help:
	@echo "Available targets:"
	@echo "  all    - Build kernel"
	@echo "  run    - Run in QEMU"
	@echo "  debug  - Run in debug mode"
	@echo "  disasm - Generate disassembly"
	@echo "  clean  - Clean build files"
```

## 🚀 常见问题解决

### 编译问题

**问题**: 找不到工具链
```bash
# 解决方案: 检查PATH
echo $PATH
which aarch64-none-elf-gcc

# 手动添加到PATH
export PATH="/usr/local/bin:$PATH"
```

**问题**: 链接错误
```bash
# 检查链接脚本语法
aarch64-none-elf-ld --verbose

# 查看详细链接信息
aarch64-none-elf-ld -Map=link.map ...
```

### QEMU问题

**问题**: QEMU启动失败
```bash
# 检查QEMU支持的机器类型
qemu-system-aarch64 -machine help

# 检查CPU类型
qemu-system-aarch64 -cpu help
```

**问题**: 无法连接GDB
```bash
# 检查端口是否被占用
netstat -an | grep 1234

# 尝试不同端口
qemu-system-aarch64 ... -gdb tcp::1235
```

### 调试问题

**问题**: 调试符号不匹配
```bash
# 确保使用相同的ELF文件
file kernel.elf
aarch64-none-elf-objdump -h kernel.elf

# 检查调试信息
aarch64-none-elf-objdump -g kernel.elf
```

## 📚 进阶技巧

### 自动化脚本

```bash
#!/bin/bash
# 自动化构建和测试脚本

set -e  # 遇到错误立即退出

echo "Building ARM64 kernel..."
make clean
make all

echo "Running tests..."
timeout 10 make run > test_output.txt 2>&1 &
QEMU_PID=$!

sleep 5
if kill -0 $QEMU_PID 2>/dev/null; then
    echo "Kernel is running successfully"
    kill $QEMU_PID
else
    echo "Kernel failed to start"
    cat test_output.txt
    exit 1
fi

echo "Tests passed!"
```

### 性能优化技巧

```bash
# 生成优化报告
aarch64-none-elf-gcc -O2 -fopt-info-all kernel.c

# 分析代码热点
aarch64-none-elf-objdump -d kernel.elf | \
    grep -E "bl|b\." | sort | uniq -c | sort -nr

# 检查对齐
aarch64-none-elf-objdump -h kernel.elf | grep -E "ALIGN|align"
```

通过掌握这些工具的使用方法，学生将能够高效地进行ARM64操作系统开发，从编译调试到性能优化，全面提升开发技能。 